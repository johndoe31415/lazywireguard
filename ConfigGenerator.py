#	lazywireguard - Quick setup of Wireguard keys and routing table
#	Copyright (C) 2021-2023 Johannes Bauer
#
#	This file is part of lazywireguard.
#
#	lazywireguard is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; this program is ONLY licensed under
#	version 3 of the License, later versions are explicitly excluded.
#
#	lazywireguard is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with lazywireguard; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#	Johannes Bauer <JohannesBauer@gmx.de>

import os
import datetime
import contextlib
import subprocess

class ConfigGenerator():
	def __init__(self, wggen, host, output_directory):
		self._wggen = wggen
		self._host = host
		self._output_directory = output_directory
		with contextlib.suppress(FileExistsError):
			os.makedirs(self._output_directory)
		os.chmod(self._output_directory, 0o700)

	@property
	def endpoint_name(self):
		return self._host["name"]

	@property
	def ifname(self):
		return self._host.get("ifname", "wg0")

	@property
	def config_filename(self):
		return f"{self._output_directory}/{self.ifname}.conf"

	@property
	def privkey_filename(self):
		return f"{self._output_directory}/{self.ifname}-private.key"

	@property
	def pubkey_filename(self):
		return f"{self._output_directory}/{self.ifname}-public.key"

	def generate_keys(self):
		self._host["key"] = { }

		if not os.path.exists(self.privkey_filename):
			privkey = subprocess.check_output([ "wg", "genkey" ])
			with open(self.privkey_filename, "wb") as f:
				f.write(privkey)
		with open(self.privkey_filename) as f:
			privkey = f.read().rstrip("\r\n")
		self._host["key"]["private"] = privkey

		if not os.path.exists(self.pubkey_filename):
			pubkey = subprocess.check_output([ "wg", "pubkey" ], input = privkey.encode("ascii"))
			with open(self.pubkey_filename, "wb") as f:
				f.write(pubkey)
		with open(self.pubkey_filename) as f:
			pubkey = f.read().rstrip("\r\n")
		self._host["key"]["public"] = pubkey

	def _get_assigned_addresses(self, host, only_host = False):
		address_strs = [ ]
		for (addr, net) in zip(host["assigned"], self._wggen.networks):
			if not only_host:
				address_strs.append(f"{addr}/{net.root_network.prefixlen}")
			else:
				address_strs.append(f"{addr}/{addr.max_prefixlen}")
		return address_strs

	def _generate_peer_client(self, f):
		allowed_networks = [ assigner.root_network for assigner in self._wggen.networks ]
		allowed_networks += self._wggen.routed

		print("[Peer]", file = f)
		print(f"Endpoint = {self._wggen.concentrator['hostname']}:{self._wggen.concentrator['port']}", file = f)
		print(f"PublicKey = {self._wggen.concentrator['key']['public']}", file = f)
		print(f"AllowedIPs = {', '.join(str(net) for net in allowed_networks)}", file = f)
		print("PersistentKeepalive = 60", file = f)

	def _generate_peer_server(self, f):
		for client in self._wggen.clients:
			allowed_networks = self._get_assigned_addresses(client, only_host = True)
			allowed_networks += [ str(network) for network in self._wggen.routed ]
			print(f"# {client['name']}", file = f)
			print("[Peer]", file = f)
			print(f"PublicKey = {client['key']['public']}", file = f)
			print(f"AllowedIPs = {', '.join(allowed_networks)}", file = f)
			print(file = f)

	def generate(self):
		with open(self.config_filename, "w") as f:
			print("# WireGuard configuration generated by https://github.com/johndoe31415/lazywireguard", file = f)
			print(f"# {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", file = f)
			print(f"# Endpoint \"{self.endpoint_name}\" of source file: {os.path.basename(self._wggen.config_filename)}", file = f)
			print("# Do not edit manually.", file = f)
			print(file = f)
			print("[Interface]", file = f)

			print(f"Address = {', '.join(self._get_assigned_addresses(self._host))}", file = f)
			if self._host["server"]:
				print(f"ListenPort = {self._wggen.concentrator['port']}", file = f)

			print(f"PrivateKey = {self._host['key']['private']}", file = f)
			if self._wggen.any_ipv6_used:
				# IPv6 requires a minimum MTU of 1280
				print("MTU = 1400", file = f)

			print(file = f)
			if self._host["server"]:
				self._generate_peer_server(f)
			else:
				self._generate_peer_client(f)
